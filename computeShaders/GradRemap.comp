#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform readonly image2D normalImage;
layout(binding = 1, rg16f) uniform readonly image2D gradients;
layout(binding = 2, rgba8) uniform image2D resultImage;
layout(binding = 3) uniform RemapParamObject {
	int kuwaharaKernelRadius;
	int averagerKernelRadius;
	float gradientThreshold;
} rpo;

void main(){
	float thresh = rpo.gradientThreshold;
	float maxDist = rpo.averagerKernelRadius;
	const ivec2 imgResolution = imageSize(normalImage);

	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
	
	vec2 grad = imageLoad(gradients, pixelCoords).rg;
	vec3 normPix = imageLoad(normalImage, pixelCoords).rgb;

	vec4 sumColour = vec4(normPix, 1.0f);

	if (!(abs(grad.x) < thresh && abs(grad.y) < thresh)){
		vec2 directionVector = grad;
		float sf = (max(grad.x, grad.y) > abs(min(grad.x, grad.y)))?max(grad.x, grad.y):min(grad.x, grad.y);
		directionVector /= sf;
		int xx = pixelCoords.x;
		int yy = pixelCoords.y;
		vec2 location = vec2(float(pixelCoords.x), float(pixelCoords.y));
		float minG;
		float midG = 0.0f;
		float maxG;
		vec3 minColour;
		vec3 maxColour;

		for (int i = 0; i != maxDist; i++){
			if (abs(grad.x) < thresh && abs(grad.y) < thresh){
				break;
			}
			grad = imageLoad(gradients, ivec2(xx, yy)).rg;
			location -= directionVector;
			xx = int(round(location.x));
			yy = int(round(location.y));
			minG = length(grad);
			midG += minG;
		}
		
		minColour = imageLoad(normalImage, ivec2(xx, yy)).rgb;//(imageLoad(normalImage, ivec2(xx, yy)).rgb != vec3(0,0,0))?imageLoad(normalImage, ivec2(xx, yy)).rgb:imageLoad(resultImage, ivec2(xx, yy)).rgb;

		xx = pixelCoords.x;
		yy = pixelCoords.y;

		grad = imageLoad(gradients, pixelCoords).rg;
		
		location = vec2(float(pixelCoords.x), float(pixelCoords.y));
		
		maxG = midG - length(grad);
		
		for (int i = 0; i != maxDist; i++){
			if (abs(grad.x) < thresh && abs(grad.y) < thresh){
				break;
			}
			grad = imageLoad(gradients, ivec2(xx,yy)).rg;
			location += directionVector;
			xx = int(round(location.x));
			yy = int(round(location.y));
			maxG += length(grad);
		}

		maxColour = imageLoad(normalImage, ivec2(xx, yy)).rgb;//(imageLoad(normalImage, ivec2(xx, yy)).rgb != vec3(0,0,0))?imageLoad(normalImage, ivec2(xx, yy)).rgb:imageLoad(resultImage, ivec2(xx, yy)).rgb;

		midG = (midG-minG)/(maxG-minG);
		float mag = clamp(midG, 0.0, 1.0);
		sumColour = (minColour != vec3(0,0,0) && maxColour != vec3(0,0,0))?vec4(minColour*(1-mag) + maxColour*mag, 1.0):sumColour;
		
		//minColour *= (1.0-mag);
		//maxColour *= mag;
		
		//sumColour = (minColour != vec3(0,0,0) && maxColour != vec3(0,0,0))?vec4(minColour + maxColour, 1.0):sumColour;
	}

	vec4 pixel = vec4(sumColour.rgb, 1.0);

	imageStore(resultImage, pixelCoords, pixel);
}