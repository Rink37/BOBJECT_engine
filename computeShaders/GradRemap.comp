#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform readonly image2D normalImage;
layout(binding = 1, rgba16) uniform readonly image2D xGrad;
layout(binding = 2, rgba16) uniform readonly image2D yGrad;
layout(binding = 3, rgba8) uniform image2D resultImage;

void main(){
	const float thresh = 0.06f;
	const ivec2 imgResolution = imageSize(normalImage);
	const int maxDist = 5;

	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	vec3 yGpix = imageLoad(yGrad, pixelCoords).rgb;
	vec3 xGpix = imageLoad(xGrad, pixelCoords).rgb;
	vec3 normPix = imageLoad(normalImage, pixelCoords).rgb;

	vec4 sumColour = vec4(normPix, 1.0f);

	if (!(abs(yGpix.r) < thresh && abs(xGpix.r) < thresh)){
		vec2 directionVector = vec2(xGpix.r, yGpix.r);
		float norm = length(directionVector);
		directionVector /= norm;
		int xx = pixelCoords.x;
		int yy = pixelCoords.y;
		vec2 location = vec2(float(pixelCoords.x), float(pixelCoords.y));
		vec2 minG = vec2(0.0,0.0);
		vec2 midG = -vec2(xGpix.r, yGpix.r);
		vec3 minColour = vec3(0.0, 0.0, 0.0);
		vec3 maxColour = vec3(0.0, 0.0, 0.0);

		while (!(abs(xGpix.r) < thresh && abs(yGpix.r) < thresh)){
			yGpix = imageLoad(yGrad, ivec2(xx, yy)).rgb;
			xGpix = imageLoad(xGrad, ivec2(xx, yy)).rgb;
			directionVector = vec2(xGpix.r, yGpix.r);
			norm = length(directionVector);
			directionVector /= norm;
			location -= directionVector;
			xx = int(location.x);
			yy = int(location.y);
			if (yy < 0 || xx < 0) {
				yy = 0;
				xx = 0;
				break;
			}
			minG = vec2(xGpix.r, yGpix.r);
			midG += minG;
		}
		minColour = imageLoad(normalImage, ivec2(xx, yy)).rgb; 
		int count = 0;
		while(minColour == vec3(0.0, 0.0, 0.0) && count < maxDist){
			location -= directionVector;
			xx = int(location.x);
			yy = int(location.y);
			count++;
			if (yy < 0 || xx < 0) {
				yy = 0;
				xx = 0;
				break;
			}
			minColour = imageLoad(normalImage, ivec2(xx, yy)).rgb; 
		}
		xx = pixelCoords.x;
		yy = pixelCoords.y;
		yGpix = imageLoad(yGrad, ivec2(xx, yy)).rgb;
		xGpix = imageLoad(xGrad, ivec2(xx, yy)).rgb;
		location = vec2(float(pixelCoords.x), float(pixelCoords.y));
		vec2 maxG = midG - vec2(xGpix.r, yGpix.r);
		
		while (!(abs(yGpix.r) < thresh && abs(xGpix.r) < thresh)){
			yGpix = imageLoad(yGrad, ivec2(xx, yy)).rgb;
			xGpix = imageLoad(xGrad, ivec2(xx, yy)).rgb;
			directionVector = vec2(xGpix.r, yGpix.r);
			norm = length(directionVector);
			directionVector /= norm;
			location += directionVector;
			xx = int(location.x);
			yy = int(location.y);
			if (yy >= imgResolution.y || xx >= imgResolution.x) {
				yy = imgResolution.y-1;
				xx = imgResolution.x-1;
				break;
			}
			maxG += vec2(xGpix.r, yGpix.r);
		}
		
		maxColour = imageLoad(normalImage, ivec2(xx, yy)).rgb;
		count = 0;
		while(maxColour == vec3(0.0, 0.0, 0.0) && count < maxDist){
			location += directionVector;
			xx = int(location.x);
			yy = int(location.y);
			count++;
			if (yy >= imgResolution.y || xx >= imgResolution.x) {
				yy = imgResolution.y-1;
				xx = imgResolution.x-1;
				break;
			}
			minColour = imageLoad(normalImage, ivec2(xx, yy)).rgb; 
		}
		midG = (midG-minG)/(maxG-minG);
		float mag = clamp(length(midG), 0.0, 1.0);
		minColour *= (1.0-mag);
		maxColour *= mag;
		
		sumColour = vec4(minColour + maxColour, 1.0);
	}

	vec4 pixel = vec4(sumColour.rgb, 1.0);

	imageStore(resultImage, pixelCoords, pixel);
}