#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform readonly image2D normalImage;
layout(binding = 1, rg16f) uniform readonly image2D gradients;
layout(binding = 2, rgba8) uniform image2D resultImage;
layout(binding = 3) uniform RemapParamObject {
	int kuwaharaKernelRadius;
	int averagerKernelRadius;
	float gradientThreshold;
} rpo;

void main(){
	int kernelRadius = rpo.averagerKernelRadius; // Min value of this is 2
	const float thresh = rpo.gradientThreshold;
	const ivec2 imgResolution = imageSize(normalImage);

	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	vec4 sumColour = vec4(0.0f, 0.0f, 0.0f, 0.0f);

	vec2 grad = imageLoad(gradients, pixelCoords).rg;
	vec3 normPix = imageLoad(normalImage, pixelCoords).rgb;

	float sf = 0.0;

	if (abs(grad.x) < thresh && abs(grad.y) < thresh){
		sf =  (normPix != vec3(0,0,0))?1.0f:0.0f;
		sumColour.rgb += normPix*sf;
		sumColour.w += sf;
		for (int x = pixelCoords.x-1; x != pixelCoords.x-kernelRadius; x--){
			grad = imageLoad(gradients, ivec2(x, pixelCoords.y)).rg;
			if (abs(grad.x) < thresh && abs(grad.y) < thresh){
				normPix = imageLoad(normalImage, ivec2(x, pixelCoords.y)).rgb;
				sf = (normPix != vec3(0,0,0))?1.0f:0.0f;
				sumColour.rgb += normPix*sf;
				sumColour.w += sf;
				for (int y = pixelCoords.y-1; y != pixelCoords.y-kernelRadius; y--){

					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (abs(grad.x) < thresh && abs(grad.y) < thresh && normPix != vec3(0,0,0))?1.0f:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;
				}
				for (int y = pixelCoords.y+1; y != pixelCoords.y+kernelRadius; y++){

					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (abs(grad.x) < thresh && abs(grad.y) < thresh && normPix != vec3(0,0,0))?1.0f:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;
				}
			}
		}
		for (int x = pixelCoords.x+1; x != pixelCoords.x+kernelRadius; x++){
			grad = imageLoad(gradients, ivec2(x, pixelCoords.y)).rg;
			if (abs(grad.x) < thresh && abs(grad.y) < thresh){
				normPix = imageLoad(normalImage, ivec2(x, pixelCoords.y)).rgb;
				sf = (normPix != vec3(0,0,0))?1.0f:0.0f;
				sumColour.rgb += normPix*sf;
				sumColour.w += sf;
				for (int y = pixelCoords.y-1; y != pixelCoords.y-kernelRadius; y--){

					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (abs(grad.x) < thresh && abs(grad.y) < thresh && normPix != vec3(0,0,0))?1.0f:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;
				}
				for (int y = pixelCoords.y+1; y != pixelCoords.y+kernelRadius; y++){

					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (abs(grad.x) < thresh && abs(grad.y) < thresh && normPix != vec3(0,0,0))?1.0f:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;
				}
			}
		}
	}

	sumColour = (sumColour != vec4(0,0,0,0))?sumColour:vec4(imageLoad(normalImage, pixelCoords).rgb, 1.0);

	vec4 pixel = vec4((sumColour.rgb/sumColour.w), 1.0);

	imageStore(resultImage, pixelCoords, pixel);
}