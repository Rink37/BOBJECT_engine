#version 450

layout (local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform readonly image2D normalImage;
layout(binding = 1, rg16f) uniform readonly image2D gradients;
layout(binding = 2, rgba8) uniform image2D resultImage;
layout(binding = 3) uniform RemapParamObject {
	int kuwaharaKernelRadius;
	int averagerKernelRadius;
	float gradientThreshold;
	float zeroCross;
	float hardness;
	float sharpness;
} rpo;

void main(){
	int kernelRadius = rpo.averagerKernelRadius; // Min value of this is 2
	const float thresh = rpo.gradientThreshold;
	const ivec2 imgResolution = imageSize(normalImage);

	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	vec4 sumColour = vec4(0.0f, 0.0f, 0.0f, 0.0f);

	vec2 grad = imageLoad(gradients, pixelCoords).rg;
	vec3 normPix = imageLoad(normalImage, pixelCoords).rgb;

	float lsf = 1.0f;
	float rsf = 1.0f;
	float tsf = 1.0f;
	float bsf = 1.0f;
	float sf = 1.0f;

	if (length(grad) < thresh){
		sf = (normPix != vec3(0,0,0))?1.0f:0.0f;
		sumColour.rgb += normPix*sf;
		sumColour.w += sf;
		for (int r = 1; r != kernelRadius; r++){
			for (int k = 0 ; k != 2; k++){
				int x = (k == 0)?pixelCoords.x-r:pixelCoords.x+r;
				sf = (k == 0)?lsf:rsf;
				grad = imageLoad(gradients, ivec2(x, pixelCoords.y)).rg;
				normPix = imageLoad(normalImage, ivec2(x, pixelCoords.y)).rgb;
				sf = (length(grad)<thresh && normPix != vec3(0,0,0))?1.0f*sf:0.0f;
				if (sf == 0.0f){
					lsf = (k==0)?sf:lsf;
					rsf = (k==0)?rsf:sf;
					continue;
				}
				sumColour.rgb += normPix*sf;
				sumColour.w += sf;
				sf = 1.0f;
				for (int y = pixelCoords.y-1; y != pixelCoords.y-kernelRadius; y--){
					
					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (length(grad) < thresh && normPix != vec3(0,0,0))?1.0f*sf:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;

					if (sf == 0.0f){
						break;
					}
				}
				sf = 1.0f;
				for (int y = pixelCoords.y+1; y != pixelCoords.y+kernelRadius; y++){

					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (length(grad) < thresh && normPix != vec3(0,0,0))?1.0f*sf:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;

					if (sf == 0.0f){
						break;
					}
				}
				lsf = (k==0)?sf:lsf;
				rsf = (k==0)?rsf:sf;
			}
		}
		for (int r = 1; r != kernelRadius; r++){
			for (int k = 0 ; k != 2; k++){
				int y = (k == 0)?pixelCoords.y-r:pixelCoords.y+r;
				sf = (k == 0)?bsf:tsf;
				grad = imageLoad(gradients, ivec2(pixelCoords.x, y)).rg;
				normPix = imageLoad(normalImage, ivec2(pixelCoords.x, y)).rgb;
				sf = (length(grad)<thresh && normPix != vec3(0,0,0))?1.0f*sf:0.0f;
				if (sf == 0.0f){
					bsf = (k==0)?sf:bsf;
					tsf = (k==0)?tsf:sf;
					continue;
				}
				sumColour.rgb += normPix*sf;
				sumColour.w += sf;
				sf = 1.0f;
				for (int x = pixelCoords.x-1; x != pixelCoords.x-kernelRadius; x--){
					
					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (length(grad) < thresh && normPix != vec3(0,0,0))?1.0f*sf:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;

					if (sf == 0.0f){
						break;
					}
				}
				sf = 1.0f;
				for (int x = pixelCoords.x+1; x != pixelCoords.x+kernelRadius; x++){

					grad = imageLoad(gradients, ivec2(x,y)).rg;
					
					normPix = imageLoad(normalImage, ivec2(x, y)).rgb;
					sf = (length(grad) < thresh && normPix != vec3(0,0,0))?1.0f*sf:0.0f;
					
					sumColour.rgb += normPix*sf;
					sumColour.w += sf;

					if (sf == 0.0f){
						break;
					}
				}
				bsf = (k==0)?sf:bsf;
				tsf = (k==0)?tsf:sf;
			}
		}
	}

	sumColour = (sumColour != vec4(0,0,0,0))?sumColour:vec4(imageLoad(normalImage, pixelCoords).rgb, 1.0);

	vec4 pixel = vec4((sumColour.rgb/sumColour.w), 1.0);

	imageStore(resultImage, pixelCoords, pixel);
}